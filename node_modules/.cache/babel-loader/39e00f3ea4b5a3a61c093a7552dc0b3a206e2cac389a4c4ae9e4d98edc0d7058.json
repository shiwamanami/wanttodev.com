{"ast":null,"code":"\"use client\";import React,{useEffect,useState,useRef}from\"react\";import{jsx as _jsx,Fragment as _Fragment,jsxs as _jsxs}from\"react/jsx-runtime\";const fadeInLeftStyle=\"\\n  @keyframes fadeInLeft {\\n    from {\\n      opacity: 0;\\n      transform: translateX(-20px);\\n    }\\n    to {\\n      opacity: 1;\\n      transform: translateX(0);\\n    }\\n  }\\n  \\n  @keyframes fadeOutLeft {\\n    from {\\n      opacity: 1;\\n      transform: translateX(0);\\n    }\\n    to {\\n      opacity: 0;\\n      transform: translateX(-20px);\\n    }\\n  }\\n  \\n  .fade-in-left-animation {\\n    animation: fadeInLeft 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;\\n  }\\n  \\n  .fade-out-left-animation {\\n    animation: fadeOutLeft 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;\\n  }\\n  \\n  .fade-out-state {\\n    opacity: 0;\\n    transform: translateX(-20px);\\n  }\\n\";export const FadeInStagger=_ref=>{let{children,delay=0,staggerDelay=200,threshold=0.1,rootMargin=\"0px 0px -50px 0px\",repeat=false}=_ref;const[visibleLines,setVisibleLines]=useState([]);const[isVisible,setIsVisible]=useState(false);const[isMounted,setIsMounted]=useState(false);const[isAnimating,setIsAnimating]=useState(false);const[isFadingOut,setIsFadingOut]=useState(false);const containerRef=useRef(null);// サーバーサイドレンダリング時とクライアント初期状態は同じ\nconst shouldShowAnimation=isMounted&&isVisible;useEffect(()=>{setIsMounted(true);},[]);useEffect(()=>{if(!isMounted)return;const observer=new IntersectionObserver(_ref2=>{let[entry]=_ref2;if(entry.isIntersecting&&!isAnimating){setIsVisible(true);setIsAnimating(true);setIsFadingOut(false);// 子要素を配列に変換\nconst childrenArray=React.Children.toArray(children);// 各子要素に対して遅延を設定\nchildrenArray.forEach((_,index)=>{setTimeout(()=>{setVisibleLines(prev=>[...prev,index]);},delay+index*staggerDelay);});// 繰り返しモードでない場合は監視を停止\nif(!repeat){observer.disconnect();}}else if(!entry.isIntersecting&&isVisible){// 要素が画面外に出た場合\nsetIsFadingOut(true);// フェードアウトアニメーション完了後に状態をリセット\nsetTimeout(()=>{setIsVisible(false);setVisibleLines([]);setIsAnimating(false);setIsFadingOut(false);},1000);// フェードアウトアニメーションの時間\n}},{threshold,rootMargin});if(containerRef.current){observer.observe(containerRef.current);}return()=>observer.disconnect();},[isMounted,children,delay,staggerDelay,threshold,rootMargin,repeat,isVisible,isAnimating]);return/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(\"style\",{children:fadeInLeftStyle}),/*#__PURE__*/_jsx(\"div\",{ref:containerRef,children:React.Children.map(children,(child,index)=>{let className=\"opacity-0 -translate-x-16\";if(isFadingOut){className=\"fade-out-left-animation\";}else if(shouldShowAnimation&&visibleLines.includes(index)){className=\"fade-in-left-animation\";}return/*#__PURE__*/_jsx(\"div\",{className:className,children:child},index);})})]});};","map":{"version":3,"names":["React","useEffect","useState","useRef","jsx","_jsx","Fragment","_Fragment","jsxs","_jsxs","fadeInLeftStyle","FadeInStagger","_ref","children","delay","staggerDelay","threshold","rootMargin","repeat","visibleLines","setVisibleLines","isVisible","setIsVisible","isMounted","setIsMounted","isAnimating","setIsAnimating","isFadingOut","setIsFadingOut","containerRef","shouldShowAnimation","observer","IntersectionObserver","_ref2","entry","isIntersecting","childrenArray","Children","toArray","forEach","_","index","setTimeout","prev","disconnect","current","observe","ref","map","child","className","includes"],"sources":["/Users/shiwa/Desktop/wanttodev.com/src/components/FadeInStagger.tsx"],"sourcesContent":["\"use client\";\nimport React, { useEffect, useState, useRef } from \"react\";\n\nconst fadeInLeftStyle = `\n  @keyframes fadeInLeft {\n    from {\n      opacity: 0;\n      transform: translateX(-20px);\n    }\n    to {\n      opacity: 1;\n      transform: translateX(0);\n    }\n  }\n  \n  @keyframes fadeOutLeft {\n    from {\n      opacity: 1;\n      transform: translateX(0);\n    }\n    to {\n      opacity: 0;\n      transform: translateX(-20px);\n    }\n  }\n  \n  .fade-in-left-animation {\n    animation: fadeInLeft 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;\n  }\n  \n  .fade-out-left-animation {\n    animation: fadeOutLeft 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;\n  }\n  \n  .fade-out-state {\n    opacity: 0;\n    transform: translateX(-20px);\n  }\n`;\n\ninterface FadeInStaggerProps {\n  children: React.ReactNode;\n  delay?: number;\n  staggerDelay?: number;\n  threshold?: number;\n  rootMargin?: string;\n  repeat?: boolean;\n}\n\nexport const FadeInStagger = ({\n  children,\n  delay = 0,\n  staggerDelay = 200,\n  threshold = 0.1,\n  rootMargin = \"0px 0px -50px 0px\",\n  repeat = false,\n}: FadeInStaggerProps) => {\n  const [visibleLines, setVisibleLines] = useState<number[]>([]);\n  const [isVisible, setIsVisible] = useState(false);\n  const [isMounted, setIsMounted] = useState(false);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isFadingOut, setIsFadingOut] = useState(false);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // サーバーサイドレンダリング時とクライアント初期状態は同じ\n  const shouldShowAnimation = isMounted && isVisible;\n\n  useEffect(() => {\n    setIsMounted(true);\n  }, []);\n\n  useEffect(() => {\n    if (!isMounted) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting && !isAnimating) {\n          setIsVisible(true);\n          setIsAnimating(true);\n          setIsFadingOut(false);\n\n          // 子要素を配列に変換\n          const childrenArray = React.Children.toArray(children);\n\n          // 各子要素に対して遅延を設定\n          childrenArray.forEach((_, index) => {\n            setTimeout(\n              () => {\n                setVisibleLines((prev) => [...prev, index]);\n              },\n              delay + index * staggerDelay\n            );\n          });\n\n          // 繰り返しモードでない場合は監視を停止\n          if (!repeat) {\n            observer.disconnect();\n          }\n        } else if (!entry.isIntersecting && isVisible) {\n          // 要素が画面外に出た場合\n          setIsFadingOut(true);\n\n          // フェードアウトアニメーション完了後に状態をリセット\n          setTimeout(() => {\n            setIsVisible(false);\n            setVisibleLines([]);\n            setIsAnimating(false);\n            setIsFadingOut(false);\n          }, 1000); // フェードアウトアニメーションの時間\n        }\n      },\n      { threshold, rootMargin }\n    );\n\n    if (containerRef.current) {\n      observer.observe(containerRef.current);\n    }\n\n    return () => observer.disconnect();\n  }, [\n    isMounted,\n    children,\n    delay,\n    staggerDelay,\n    threshold,\n    rootMargin,\n    repeat,\n    isVisible,\n    isAnimating,\n  ]);\n\n  return (\n    <>\n      <style>{fadeInLeftStyle}</style>\n      <div ref={containerRef}>\n        {React.Children.map(children, (child, index) => {\n          let className = \"opacity-0 -translate-x-16\";\n\n          if (isFadingOut) {\n            className = \"fade-out-left-animation\";\n          } else if (shouldShowAnimation && visibleLines.includes(index)) {\n            className = \"fade-in-left-animation\";\n          }\n\n          return (\n            <div key={index} className={className}>\n              {child}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n"],"mappings":"AAAA,YAAY,CACZ,MAAO,CAAAA,KAAK,EAAIC,SAAS,CAAEC,QAAQ,CAAEC,MAAM,KAAQ,OAAO,CAAC,OAAAC,GAAA,IAAAC,IAAA,CAAAC,QAAA,IAAAC,SAAA,CAAAC,IAAA,IAAAC,KAAA,yBAE3D,KAAM,CAAAC,eAAe,oqBAmCpB,CAWD,MAAO,MAAM,CAAAC,aAAa,CAAGC,IAAA,EAOH,IAPI,CAC5BC,QAAQ,CACRC,KAAK,CAAG,CAAC,CACTC,YAAY,CAAG,GAAG,CAClBC,SAAS,CAAG,GAAG,CACfC,UAAU,CAAG,mBAAmB,CAChCC,MAAM,CAAG,KACS,CAAC,CAAAN,IAAA,CACnB,KAAM,CAACO,YAAY,CAAEC,eAAe,CAAC,CAAGlB,QAAQ,CAAW,EAAE,CAAC,CAC9D,KAAM,CAACmB,SAAS,CAAEC,YAAY,CAAC,CAAGpB,QAAQ,CAAC,KAAK,CAAC,CACjD,KAAM,CAACqB,SAAS,CAAEC,YAAY,CAAC,CAAGtB,QAAQ,CAAC,KAAK,CAAC,CACjD,KAAM,CAACuB,WAAW,CAAEC,cAAc,CAAC,CAAGxB,QAAQ,CAAC,KAAK,CAAC,CACrD,KAAM,CAACyB,WAAW,CAAEC,cAAc,CAAC,CAAG1B,QAAQ,CAAC,KAAK,CAAC,CACrD,KAAM,CAAA2B,YAAY,CAAG1B,MAAM,CAAiB,IAAI,CAAC,CAEjD;AACA,KAAM,CAAA2B,mBAAmB,CAAGP,SAAS,EAAIF,SAAS,CAElDpB,SAAS,CAAC,IAAM,CACduB,YAAY,CAAC,IAAI,CAAC,CACpB,CAAC,CAAE,EAAE,CAAC,CAENvB,SAAS,CAAC,IAAM,CACd,GAAI,CAACsB,SAAS,CAAE,OAEhB,KAAM,CAAAQ,QAAQ,CAAG,GAAI,CAAAC,oBAAoB,CACvCC,KAAA,EAAa,IAAZ,CAACC,KAAK,CAAC,CAAAD,KAAA,CACN,GAAIC,KAAK,CAACC,cAAc,EAAI,CAACV,WAAW,CAAE,CACxCH,YAAY,CAAC,IAAI,CAAC,CAClBI,cAAc,CAAC,IAAI,CAAC,CACpBE,cAAc,CAAC,KAAK,CAAC,CAErB;AACA,KAAM,CAAAQ,aAAa,CAAGpC,KAAK,CAACqC,QAAQ,CAACC,OAAO,CAACzB,QAAQ,CAAC,CAEtD;AACAuB,aAAa,CAACG,OAAO,CAAC,CAACC,CAAC,CAAEC,KAAK,GAAK,CAClCC,UAAU,CACR,IAAM,CACJtB,eAAe,CAAEuB,IAAI,EAAK,CAAC,GAAGA,IAAI,CAAEF,KAAK,CAAC,CAAC,CAC7C,CAAC,CACD3B,KAAK,CAAG2B,KAAK,CAAG1B,YAClB,CAAC,CACH,CAAC,CAAC,CAEF;AACA,GAAI,CAACG,MAAM,CAAE,CACXa,QAAQ,CAACa,UAAU,CAAC,CAAC,CACvB,CACF,CAAC,IAAM,IAAI,CAACV,KAAK,CAACC,cAAc,EAAId,SAAS,CAAE,CAC7C;AACAO,cAAc,CAAC,IAAI,CAAC,CAEpB;AACAc,UAAU,CAAC,IAAM,CACfpB,YAAY,CAAC,KAAK,CAAC,CACnBF,eAAe,CAAC,EAAE,CAAC,CACnBM,cAAc,CAAC,KAAK,CAAC,CACrBE,cAAc,CAAC,KAAK,CAAC,CACvB,CAAC,CAAE,IAAI,CAAC,CAAE;AACZ,CACF,CAAC,CACD,CAAEZ,SAAS,CAAEC,UAAW,CAC1B,CAAC,CAED,GAAIY,YAAY,CAACgB,OAAO,CAAE,CACxBd,QAAQ,CAACe,OAAO,CAACjB,YAAY,CAACgB,OAAO,CAAC,CACxC,CAEA,MAAO,IAAMd,QAAQ,CAACa,UAAU,CAAC,CAAC,CACpC,CAAC,CAAE,CACDrB,SAAS,CACTV,QAAQ,CACRC,KAAK,CACLC,YAAY,CACZC,SAAS,CACTC,UAAU,CACVC,MAAM,CACNG,SAAS,CACTI,WAAW,CACZ,CAAC,CAEF,mBACEhB,KAAA,CAAAF,SAAA,EAAAM,QAAA,eACER,IAAA,UAAAQ,QAAA,CAAQH,eAAe,CAAQ,CAAC,cAChCL,IAAA,QAAK0C,GAAG,CAAElB,YAAa,CAAAhB,QAAA,CACpBb,KAAK,CAACqC,QAAQ,CAACW,GAAG,CAACnC,QAAQ,CAAE,CAACoC,KAAK,CAAER,KAAK,GAAK,CAC9C,GAAI,CAAAS,SAAS,CAAG,2BAA2B,CAE3C,GAAIvB,WAAW,CAAE,CACfuB,SAAS,CAAG,yBAAyB,CACvC,CAAC,IAAM,IAAIpB,mBAAmB,EAAIX,YAAY,CAACgC,QAAQ,CAACV,KAAK,CAAC,CAAE,CAC9DS,SAAS,CAAG,wBAAwB,CACtC,CAEA,mBACE7C,IAAA,QAAiB6C,SAAS,CAAEA,SAAU,CAAArC,QAAA,CACnCoC,KAAK,EADER,KAEL,CAAC,CAEV,CAAC,CAAC,CACC,CAAC,EACN,CAAC,CAEP,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}